"""
Shell interaction utilities for the aliaser tool.

This module provides functions for detecting the current shell,
managing shell configuration files, and handling aliases.
"""

import os
import re
from pathlib import Path

import shellingham

from app.utils import is_command_in_path, backup_file, safe_write_file

# Constants
SUPPORTED_SHELLS = {"bash", "zsh", "fish"}
SHELL_RESERVED_WORDS = {
    "bash": {
        "if",
        "then",
        "else",
        "elif",
        "fi",
        "case",
        "esac",
        "for",
        "select",
        "while",
        "until",
        "do",
        "done",
        "in",
        "function",
        "time",
        "cd",
        "ls",
    },
    "zsh": {
        "if",
        "then",
        "else",
        "elif",
        "fi",
        "case",
        "esac",
        "for",
        "select",
        "while",
        "until",
        "do",
        "done",
        "in",
        "function",
        "time",
        "cd",
        "ls",
    },
    "fish": {
        "if",
        "else",
        "switch",
        "case",
        "while",
        "for",
        "in",
        "end",
        "and",
        "or",
        "not",
        "cd",
        "ls",
        "set",
        "function",
    },
}

# Markers for the aliaser section in shell config files
SECTION_START = "# BEGIN GENERATED BY ALIASER"
SECTION_END = "# END GENERATED BY ALIASER"


def detect_shell() -> str:
    """
    Detect the current shell using shellingham.

    Returns:
        str: The name of the detected shell (e.g., 'bash', 'zsh', 'fish')

    Raises:
        RuntimeError: If the shell cannot be detected or is not supported
    """
    try:
        shell_info = shellingham.detect_shell()
        shell_name: str = shell_info[0]

        if shell_name not in SUPPORTED_SHELLS:
            raise RuntimeError(
                f"Shell '{shell_name}' is not supported. "
                f"Supported shells: {', '.join(SUPPORTED_SHELLS)}"
            )

        return shell_name
    except shellingham.ShellDetectionFailure as e:
        raise RuntimeError(
            "Could not detect your shell. Please ensure you're using "
            f"a supported shell: {', '.join(SUPPORTED_SHELLS)}"
        ) from e


def get_shell_config_path(shell_name: str) -> Path:
    """
    Get the path to the shell's configuration file.

    Args:
        shell_name (str): The name of the shell

    Returns:
        Path: Path to the shell configuration file

    Raises:
        ValueError: If the shell is not supported
    """
    home_dir = Path.home()

    if shell_name == "bash":
        # Check for .bash_profile first (macOS preference)
        bash_profile = home_dir / ".bash_profile"
        if bash_profile.exists():
            return bash_profile

        return home_dir / ".bashrc"

    if shell_name == "zsh":
        return home_dir / ".zshrc"

    if shell_name == "fish":
        fish_config_dir = home_dir / ".config" / "fish"
        fish_config_dir.mkdir(parents=True, exist_ok=True)
        return fish_config_dir / "config.fish"

    raise ValueError(f"Unsupported shell: {shell_name}")


def _ensure_aliaser_section(config_path: Path) -> None:
    """
    Ensure that the aliaser section exists in a shell config file.
    If it doesn't exist, create it at the end of the file.

    Args:
        config_path (Path): Path to the shell config file
    """
    if not config_path.exists():
        # Create the file if it doesn't exist
        config_path.parent.mkdir(parents=True, exist_ok=True)
        config_path.touch()
        content = (
            f"{SECTION_START}\n# Aliases managed by aliaser - "
            + f"DO NOT EDIT THIS SECTION MANUALLY\n{SECTION_END}\n"
        )
        safe_write_file(config_path, content)
        return

    # Read the file content
    try:
        content = config_path.read_text()
    except Exception as e:
        raise IOError(f"Could not read shell config file: {e}") from e

    # Check if the section already exists
    if SECTION_START not in content:
        # Back up the file before modifying
        backup_file(config_path)

        # Add the section at the end of the file
        with open(config_path, "a", encoding="utf-8") as f:
            if content and not content.endswith("\n\n"):
                f.write("\n\n" if not content.endswith("\n") else "\n")
            f.write(
                f"{SECTION_START}\n# Aliases managed by aliaser - "
                + f"DO NOT EDIT THIS SECTION MANUALLY\n{SECTION_END}\n"
            )


def _get_aliaser_section_lines_range(config_path: Path) -> tuple[int, int]:
    """
    Get the aliaser section from a shell configuration file.

    Args:
        config_path (Path): Path to the shell config file

    Returns:
        Tuple[int, int]: The start line index, end line index

    Raises:
        RuntimeError: If the section is not found
    """
    # Ensure the section exists
    _ensure_aliaser_section(config_path)

    try:
        # Read the file content
        content = config_path.read_text()
        lines = content.splitlines()

        # Find the section
        start_idx = -1
        end_idx = -1

        for i, line in enumerate(lines):
            if line.strip() == SECTION_START:
                start_idx = i
            elif line.strip() == SECTION_END and start_idx != -1:
                end_idx = i
                break

        if start_idx == -1 or end_idx == -1:
            raise RuntimeError(
                "Aliaser managed section not found in the config file. "
                "This is a bug, please report it."
            )

        return start_idx, end_idx
    except Exception as e:
        raise RuntimeError(f"Error reading shell config file: {e}") from e


def _get_alias_format(shell_name: str, alias: str, command: str) -> str:
    """
    Format an alias command for the specific shell.

    Args:
        shell_name (str): The name of the shell
        alias (str): The alias name
        command (str): The command

    Returns:
        str: Formatted alias command
    """
    if shell_name in {"bash", "zsh"}:
        # Escape quotes in the command
        escaped_command = command.replace('"', '\\"')
        return f'alias {alias}="{escaped_command}"'

    if shell_name == "fish":
        # Escape quotes in the command
        escaped_command = command.replace("'", "\\'")
        return f"alias {alias} '{escaped_command}'"

    raise ValueError(f"Unsupported shell: {shell_name}")


def _line_defines_alias(line: str, alias: str, shell_name: str) -> bool:
    """
    Check if a line defines the specified alias.

    Args:
        line (str): The line to check
        alias (str): The alias name
        shell_name (str): The name of the shell

    Returns:
        bool: True if the line defines the alias
    """
    if shell_name in {"bash", "zsh"}:
        pattern = rf"^\s*alias\s+{re.escape(alias)}="
    elif shell_name == "fish":
        pattern = rf"^\s*alias\s+{re.escape(alias)}\s+"
    else:
        return False

    return bool(re.match(pattern, line))


def add_alias_to_shell(
    shell_name: str, config_path: Path, alias: str, command: str, force: bool = False
) -> bool:
    """
    Add an alias to the shell configuration file.

    Args:
        shell_name (str): The name of the shell
        config_path (Path): Path to the shell config file
        alias (str): The alias name
        command (str): The command

    Returns:
        bool: True if the alias was added, False if it already exists with the same command

    Raises:
        RuntimeError: If there's an error writing to the config file
    """
    # Check if the alias already exists
    if not force and alias in get_all_aliases(shell_name, config_path):
        return False  # Already exists a command with this alias

    # Get the aliaser section
    start_idx, end_idx = _get_aliaser_section_lines_range(config_path)

    try:
        # Read the file content
        content = config_path.read_text()
        lines = content.splitlines()

        # Format the alias command
        alias_cmd = _get_alias_format(shell_name, alias, command)

        # Create the new section content
        new_section_lines = [SECTION_START]
        new_section_lines.append("# Aliases managed by aliaser - DO NOT EDIT THIS SECTION MANUALLY")

        # Add all existing aliases except for the one we're updating (if it exists)
        for line in lines[start_idx + 1 : end_idx]:
            if not line.strip() or line.startswith("#"):
                continue

            if _line_defines_alias(line, alias, shell_name):
                continue

            new_section_lines.append(line)

        # Add the new alias
        new_section_lines.append(alias_cmd)
        new_section_lines.append(SECTION_END)

        # Replace the section in the file
        new_lines = lines[:start_idx] + new_section_lines + lines[end_idx + 1 :]

        # Back up the file before modifying
        backup_file(config_path)

        # Write the file
        result = safe_write_file(config_path, "\n".join(new_lines))
        if not result:
            raise RuntimeError("Failed to write to shell config file")
        return True

    except Exception as e:
        raise RuntimeError(f"Error writing to config file: {e}") from e


def remove_alias_from_shell(shell_name: str, config_path: Path, alias: str) -> bool:
    """
    Remove an alias from the shell configuration file.

    Args:
        shell_name (str): The name of the shell
        config_path (Path): Path to the shell config file
        alias (str): The alias to remove

    Returns:
        bool: True if the alias was removed, False if not found

    Raises:
        RuntimeError: If there's an error writing to the config file
    """
    # Get the current aliases
    aliases = get_all_aliases(shell_name, config_path)

    # Check if the alias exists
    if alias not in aliases:
        return False

    try:
        # Get the aliaser section
        start_idx, end_idx = _get_aliaser_section_lines_range(config_path)

        # Read the file content
        content = config_path.read_text()
        lines = content.splitlines()

        # Create the new section content
        new_section_lines = [SECTION_START]
        new_section_lines.append("# Aliases managed by aliaser - DO NOT EDIT THIS SECTION MANUALLY")

        # Add all existing aliases except for the one we're removing
        for line in lines[start_idx + 1 : end_idx]:
            if line.strip() and not line.startswith("#"):
                if not _line_defines_alias(line, alias, shell_name):
                    new_section_lines.append(line)

        new_section_lines.append(SECTION_END)

        # Replace the section in the file
        new_lines = lines[:start_idx] + new_section_lines + lines[end_idx + 1 :]

        # Back up the file before modifying
        backup_file(config_path)

        # Write the file
        return safe_write_file(config_path, "\n".join(new_lines))

    except Exception as e:
        raise RuntimeError(f"Error writing to config file: {e}") from e


def update_alias_in_shell(shell_name: str, config_path: Path, alias: str, command: str) -> bool:
    """
    Update an alias in the shell configuration file.

    Args:
        shell_name (str): The name of the shell
        config_path (Path): Path to the shell config file
        alias (str): The alias to update
        command (str): The new command

    Returns:
        bool: True if the alias was updated, False if not found

    Raises:
        RuntimeError: If there's an error writing to the config file
    """
    # Get the current aliases
    aliases = get_all_aliases(shell_name, config_path)

    # Check if the alias exists
    if alias not in aliases:
        return False

    # Remove the alias and add it again with the new command
    removed = remove_alias_from_shell(shell_name, config_path, alias)
    if not removed:
        return False

    return add_alias_to_shell(shell_name, config_path, alias, command)


def get_all_aliases(shell_name: str, config_path: Path) -> dict[str, str]:
    """
    Get all aliases managed by aliaser.

    Args:
        shell_name (str): The name of the shell
        config_path (Path): Path to the shell config file

    Returns:
        Dict[str, str]: Dictionary mapping alias names to commands
    """
    try:
        # Ensure the section exists
        _ensure_aliaser_section(config_path)

        # Get the aliaser section
        start_idx, end_idx = _get_aliaser_section_lines_range(config_path)

        # Read the file content
        content = config_path.read_text()
        lines = content.splitlines()

        # Extract aliases
        aliases = {}

        for line in lines[start_idx + 1 : end_idx]:
            if line.strip() and not line.startswith("#"):
                if shell_name in {"bash", "zsh"}:
                    # Format: alias name="command"
                    match = re.match(r'^\s*alias\s+([^=]+)="(.+)"\s*$', line)
                    if match:
                        alias_name = match.group(1).strip()
                        command = match.group(2)
                        aliases[alias_name] = command

                elif shell_name == "fish":
                    # Format: alias name 'command'
                    match = re.match(r"^\s*alias\s+([^\s]+)\s+'(.+)'\s*$", line)
                    if match:
                        alias_name = match.group(1).strip()
                        command = match.group(2)
                        aliases[alias_name] = command

        return aliases

    except Exception as e:
        raise RuntimeError(f"Error reading aliases from shell config file: {e}") from e


def is_valid_alias_name(alias: str) -> bool:
    """
    Validate an alias name against reserved words and existing commands.

    Args:
        alias (str): The alias name to validate

    Returns:
        bool: True if the alias name is valid, False otherwise
    """
    shell = detect_shell()

    # Check shell reserved words
    reserved_words = SHELL_RESERVED_WORDS[shell]
    if alias in reserved_words:
        return False

    # Check system commands
    if is_command_in_path(alias):
        return False

    # Check for invalid characters or formats
    if not re.match(r"^[a-zA-Z0-9_-]+$", alias):
        return False

    return True


def run_shell_command(command: str) -> None:
    """
    Run a shell command.
    """
    shell_name = detect_shell()

    match shell_name:
        case "zsh":
            os.system(f"zsh -c '{command}'")
        case "bash":
            os.system(f"bash -c '{command}'")
        case "fish":
            os.system(f"fish -c '{command}'")
        case _:
            raise RuntimeError(f"Unsupported shell: {shell_name}")
